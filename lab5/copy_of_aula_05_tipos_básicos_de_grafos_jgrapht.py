# -*- coding: utf-8 -*-
"""Copy of Aula 05 - Tipos Básicos de Grafos - JGraphT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18105aIBJlTtgdWHXH9krxHoeRBJnsgsO

# Tipos Básicos de Grafos

Neste notebook, exploramos recursos da **JGraphT** para analisar propriedades de um grafo, conhecer geradores padrão de grafos e travessia do grafo.

A documentação sobre **Python bindings** encontra-se no link abaixo:

https://python-jgrapht.readthedocs.io/en/jgrapht-1.5.0.3/

# Instalação da JGraphT e Importação de Pacotes e Arquivos deste Notebook
"""

# Instalando a JgraphT para uso neste notebook
!pip install jgrapht

# Importando a JgraphT
import jgrapht

# Importanto funções para print de vértices e arestas
!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/python/getutil.py
!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/python/drawutil.py
!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/python/importutil.py
from getutil import get_edge_labels, get_partitions
from importutil import import_gml
from drawutil import draw_graph

# Download de arquivos de grafos usados neste notebook
!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/graphs/bp1.gml
!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/graphs/cubo.gml
!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/graphs/acyclic.gml
!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/graphs/K5.gml
!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/graphs/pseudograph-Aula02.gml

"""# Testando Propriedades em um Grafo

JGraphT apresenta uma coleção de funções para computar várias propriedades sobre um grafo no pacote [jgrapht.properties](https://python-jgrapht.readthedocs.io/en/jgrapht-1.5.0.1/api/properties.html#structural-properties). Dentre elas, podemos destacar a função **has_multipleedges** que determina se um grafo passado como parâmetro possui arestas paralelas. O método **has_selfloops** determina se um grafo possui arestas loop.  O método **is_strongly_connected** determina se um grafo é conectado. O método **is_bipartite** determina se um grafo é bipartido. O método **is_complete** determina se um grafo é completo. Dentre outros métodos, que testam conceitos que serão apresentados em aulas posteriores.
"""

#@title  { run: "auto", vertical-output: true }
filename = "cubo.gml" #@param ["bp1.gml", "cubo.gml", "acyclic.gml", "K5.gml", "pseudograph-Aula02.gml"]
layout = "circular" #@param ["random", "circular", "fruchterman_reingold", "fruchterman_reingold_indexed"]

from jgrapht.properties import has_multipleedges
from jgrapht.properties import has_selfloops
from jgrapht.properties import is_strongly_connected
from jgrapht.properties import is_bipartite
from jgrapht.properties import is_complete

v_g0 = {}
e_g0 = {}
g0 = jgrapht.create_graph(directed=False,weighted=False,
                          allowing_multiple_edges=True,
                          allowing_self_loops=True)
import_gml(g0,v_g0,e_g0,filename)
if not has_multipleedges(g0) and not has_selfloops(g0):
  draw_graph(g0,layout,vlabel='label',v_attrs=v_g0,
             elabel='label',e_attrs=e_g0)
print(get_edge_labels(g0,v_attrs=v_g0,e_attrs=e_g0))

# Testando propriedades de G
print("Grafo possui arestas pararelas? {}".
      format(bool(has_multipleedges(g0))))
print("Grafo possui arestas loop? {}".
      format(bool(has_selfloops(g0))))
print("O Grafo é conectado? {}".
      format(bool(is_strongly_connected(g0))))
print("O Grafo é bipartido? {}".
      format(bool(is_bipartite(g0))))
print("O Grafo é completo? {}".
      format(bool(is_complete(g0))))

"""# Geradores de Grafos

A JGraphT disponibiliza geradores automáticos de grafos com base em vários modelos conhecidos através do pacote [Generators](https://python-jgrapht.readthedocs.io/en/jgrapht-1.5.0.3/api/generators.html). Abaixo ilustramos alguns deles.
"""

#@title Grafo Completo { run: "auto", vertical-output: true }
size = 10 #@param {type:"slider", min:1, max:10, step:1}
# GRAFO COMPLETO

#Criando uma instância vazia
cgraph = jgrapht.create_graph(directed=False,weighted=False)

# Gerando um grafo completo com n vértices
jgrapht.generators.complete_graph(cgraph,size)

print(cgraph.vertices)
print({cgraph.edge_tuple(e)[0:2] for e in cgraph.edges})
draw_graph(cgraph,layout='circular',vertexid_aslabel=True)

#@title Grafo Vazio { run: "auto", vertical-output: true }
size = 9 #@param {type:"slider", min:1, max:10, step:1}
# GRAFO VAZIO

#Criando uma instância vazia
vgraph = jgrapht.create_graph(directed=False,weighted=False)

# Gerando um grafo completo com n vértices
jgrapht.generators.empty_graph(vgraph,size)

print(vgraph.vertices)
print({vgraph.edge_tuple(e)[0:2] for e in vgraph.edges})
draw_graph(vgraph,layout='circular',vertexid_aslabel=True)

#@title Grafo Bipartido Completo { run: "auto", vertical-output: true }
p1 = 4 #@param {type:"slider", min:1, max:10, step:1}
p2 = 3 #@param {type:"slider", min:1, max:10, step:1}
# GRAFO BIPARTIDO COMPLETO

#Criando uma instância vazia
bcgraph = jgrapht.create_graph(directed=False,weighted=False)

# Gerando um grafo bipartido completo passando o tamanho das partições
jgrapht.generators.complete_bipartite_graph(bcgraph,p1,p2)

print(bcgraph.vertices)
print({bcgraph.edge_tuple(e)[0:2] for e in bcgraph.edges})

# Encontra as partições de um grafo bipartido
partition1,partition2 = get_partitions(bcgraph)

draw_graph(bcgraph,vertexid_aslabel=True,vertex_font_color="white",
           vset=[partition1,partition2],vsetcolor=["red","blue"],
           vsetlabel=["Partição 1","Partição 2"])

#@title Grafo Caminho { run: "auto", vertical-output: true }
qvertices = 7 #@param {type:"slider", min:1, max:20, step:1}
# GRAFO CAMINHO

#Criando uma instância vazia
pgraph = jgrapht.create_graph(directed=False,weighted=False)

# Gerando um grafo caminho de n vértices
jgrapht.generators.linear(pgraph,qvertices)

print(pgraph.vertices)
print({pgraph.edge_tuple(e)[0:2] for e in pgraph.edges})
draw_graph(pgraph,layout='fruchterman_reingold_indexed',vertexid_aslabel=True)

#@title Grafo Ciclo { run: "auto", vertical-output: true }
qvertices = 14 #@param {type:"slider", min:3, max:20, step:1}
# GRAFO Ciclo

#Criando uma instância vazia
cigraph = jgrapht.create_graph(directed=False,weighted=False)

# Gerando um grafo caminho de n vértices
jgrapht.generators.ring_graph(cigraph,qvertices)

print(cigraph.vertices)
print({cigraph.edge_tuple(e)[0:2] for e in cigraph.edges})
draw_graph(cigraph,layout='circular',vertexid_aslabel=True)

#@title Complemento { run: "auto", vertical-output: true }
# COMPLEMENTO

#Criando uma instância vazia
compgraph = jgrapht.create_graph(directed=False,weighted=False)

# Gerando o complemento do grafo ciclo 'cigraph' criado anteriormente
jgrapht.generators.complement_graph(compgraph,cigraph)

print("Grafo Ciclo:")
print(cigraph.vertices)
print({cigraph.edge_tuple(e)[0:2] for e in cigraph.edges})
print("Complemento:")
print(compgraph.vertices)
print({compgraph.edge_tuple(e)[0:2] for e in compgraph.edges})
draw_graph(compgraph,layout='circular',vertexid_aslabel=True)

#@title Random { run: "auto", vertical-output: true }
# RANDOM

#Criando uma instância vazia
rgraph = jgrapht.create_graph(directed=False,weighted=False)

# Gerando um grafo randomico com n vértices e m arestas
jgrapht.generators.gnm_random_graph(rgraph,8,10)

print(rgraph.vertices)
print({rgraph.edge_tuple(e)[0:2] for e in rgraph.edges})
draw_graph(rgraph,layout='circular',vertexid_aslabel=True)

"""# Travessia do Grafo (Graph Traversal)

Travessia de grafo (*graph traversal*) refere-se ao processo de visitar cada vértice de um grafo observando o padrão de conexão entre eles. Usualmente, o próximo vértice a visitar é um vizinho do vértice corrente (ou existe um passeio entre eles). Em um grafo desconectado, os vértices de cada componente são todos visitados antes que os vértices de outros componentes sejam visitados (ver acyclic.gml no exemplo abaixo).
A JGraphT dá suporte a implementação de alguns algoritmos conhecidos retornando um iterador ([pacote traversal](https://python-jgrapht.readthedocs.io/en/jgrapht-1.5.0.3/api/traversals.html)). Estes algoritmos serão estudados em mais detalhes em aulas posteriores.
"""

#@title   { run: "auto", vertical-output: true }
filename = "acyclic.gml" #@param ["bp1.gml", "cubo.gml", "acyclic.gml", "K5.gml", "pseudograph-Aula02.gml"]
layout = "circular" #@param ["random", "circular", "fruchterman_reingold", "fruchterman_reingold_indexed"]
v_attrs = {}
e_attrs = {}
g = jgrapht.create_graph(directed=False,weighted=False,
                         allowing_multiple_edges=True,
                         allowing_self_loops=True)
import_gml(g,v_attrs,e_attrs,filename)
draw_graph(g,layout,vlabel='label',v_attrs=v_attrs,elabel='label',e_attrs=e_attrs)

bfs = jgrapht.traversal.bfs_traversal(g)
print("BFS")
for v in bfs:
  print(v_attrs[v]['label'],end=' ')
dfs = jgrapht.traversal.dfs_traversal(g)
print("\nDFS")
for v in dfs:
  print(v_attrs[v]['label'],end=' ')
max = jgrapht.traversal.max_cardinality_traversal(g)
print("\nMAX")
for v in max:
  print(v_attrs[v]['label'],end=' ')

"""# Exercício

Construa uma função que recebe um grafo como entrada e determina se duas partições de vértices são conectadas.
"""

#@title   { run: "auto", vertical-output: true }
filename = "acyclic.gml" #@param ["bp1.gml", "cubo.gml", "acyclic.gml", "K5.gml", "pseudograph-Aula02.gml"]
layout = "circular" #@param ["random", "circular", "fruchterman_reingold", "fruchterman_reingold_indexed"]
v_g1 = {}
e_g1 = {}
g1 = jgrapht.create_graph(directed=False,weighted=False,
                          allowing_multiple_edges=True,
                          allowing_self_loops=True)
import_gml(g1,v_g1,e_g1,filename)
draw_graph(g1,layout,vertexid_aslabel=True)

def connectedp (g,p1,p2):
  for i in p1:
    for c in p2:
      if(g1.contains_edge_between(i,c)):
        return True
  return False

connectedp (g1,[0,1,2,3,4],[7])

# Testando se os vértices 0 e 1 estão relacionados no grafo g criado acima.
# (execute o código anterior antes deste para criar o grafo)
# Observe que tanto faz testar a aresta (1,0) quanto (0,1) já
# que o grafo é não direcionado.
if (g1.contains_edge_between(0,1) and g1.contains_edge_between(1,0)):
  print(True)

"""A interface *Graph* também disponibiliza métodos para consultarmos se vértices estão ou não relacionados (*contains_edge_between*, *edges_between*), de quais arestas um vértice é terminal (*edges_of*), qual é o outro vértice terminal de uma aresta (*opposite*) e o grau de um vértice (*degree_of*), dentre outras. Existem outras funções especializadas para grafos direcionados e grafos ponderados. Abaixo, ilustram os um teste para mostrar que em grafos não-direcionados a ordem dos terminais não importa.

A interface *Graph* também disponibiliza métodos para consultarmos se vértices estão ou não relacionados (*contains_edge_between*, *edges_between*), de quais arestas um vértice é terminal (*edges_of*), qual é o outro vértice terminal de uma aresta (*opposite*) e o grau de um vértice (*degree_of*), dentre outras. Existem outras funções especializadas para grafos direcionados e grafos ponderados. Abaixo, ilustram os um teste para mostrar que em grafos não-direcionados a ordem dos terminais não importa.

A interface *Graph* também disponibiliza métodos para consultarmos se vértices estão ou não relacionados (*contains_edge_between*, *edges_between*), de quais arestas um vértice é terminal (*edges_of*), qual é o outro vértice terminal de uma aresta (*opposite*) e o grau de um vértice (*degree_of*), dentre outras. Existem outras funções especializadas para grafos direcionados e grafos ponderados. Abaixo, ilustram os um teste para mostrar que em grafos não-direcionados a ordem dos terminais não importa.
"""